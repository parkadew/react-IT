

redux를 사용하는 이유 3가지
1. 전역 상태 관리
2. 단방향 데이터 흐름을 통한 상태 중앙 관리 -> 에러 추적 용이
3. 다양한 플러그인 및 미들웨어 지원

=> redux의 단점
사용하기 위해 작성해야하는 코드가 많으며, 중앙 상태 관리를 강요

@redux-tool-kit (RTK)
=> redux의 단점을 보완하고자 나온 라이브러리이지만, 아쉽게도 큰 호응은 얻지 못했음
=> redux는 플러그인들을 자체 설치 <-- (다른 사람이 만든 라이브러리), 다른 사람들이 관리안하면 지원을 안해요
=> rtk는 플러그인들을 자체 지원 (devtools, middle ware)
=> 작성하기 위한 코드는 조금 줄어들었습니다

현재 실무에서 가장 많이 사용하는 전역 상태 관리 도구

1. redux + saga/thunk / rtk
2. mobx
3. jotai, zustand
4. recoil

------------------------------------------

msw (mocking api)

프론트엔드개발자
백엔드개발자가 동시에 개발을 시작

백엔드 api(주소)가 나오지 않으면 개발을 멈춰야한다?
아니면 백엔드 api를 가상으로 만들어 개발을 이어가야한다.

백엔드가 없이도 개발이 가능하게끔 (mocking) - axios, fetch
실제 백엔드에 요청하지 않아도 테스크 코드나 테스트 시나리오를 작성할 수 있다
(실제 백엔드 요청하지 않고 프론트엔드가 정상적으로 동작하는지 확인이 가능)

왜 실제 백엔드 요청하면 안되는지
1. 프론트엔드는 백엔드와 상관없이 정상적으로 작동
2. 다양한 시나리오 분석이 가능 (실패할 경우의 요청)
3. 백엔드가 인터넷이나 오류로 작동하지 않을 때 테스트를 못해보는 경우가 없음

가상의 api를 만들어서 테스트하거나, 테스크(업무)를 진행하는 경우가 많아요 ---> msw

------------------------------------------

테스트 코드

A라는 기능을 개발 --> B라는 기능에 이슈가 생길 수 있을까요?
여러분들은 개발을 할 때마다 처음부터 끝까지 정상 작동하는지 직접 확인

HR이 발생, 사람보다 기계로 테스트하는 것이 훨씬 저렴하고 속도가 빠르지 않을까?
내가 개발한 기능을 테스트하는 코드를 작성해보자 --> "테스트 코드"

jest, vi-test

TDD(test driven development) 테스트 주도 개발
실제 기능을 작성하지 전에 테스트 코드를 먼저 작성하고 기능을 개발

반면에 프론트엔드는 테스트 코드를 엄격하게 작성하지 않아요 -> 변경이 많다
변경이 될 떄마다, 테스트 코드도 함께 수정해야한다 -> 리소스 발생

간단한 모듈 테스트나, e2e 테스트
프론트엔드 테스트 코드를 작성할 때 "백엔드에 요청" --> 실제 유저가 회원가입(유령 회원) -> 백엔드가 작동하지 않으면 프론트는 테스트 코드를 작동하지 못해요

한계가 발생(불편함) => msw => 백엔드를 모킹하고 백엔드와 상관없이 프론트 엔드를 개발 및 테스트 할 수 있도록

------------------------------------------

>> redux-thunk

------------------------------------------

이전까지 수강생 80명 / 6개월만해도 개발자할 수 있어요!
목적이 취업, 간절한 분들도 되게 많았어요
수업 자료를 엎어버렸어요 -> 인터넷 강의만 800만 --> 지금 제가하고 있는 수업자료
사람들이 간절하다보니까 하루에 학습시간이 5시간

현재 수강생 20~30명 / 1년 정도해야 개발자가 될 수 있는 기회를 얻을 수 있어요!
목적 프론트엔드 공부 / 당장 간절하지 않아요
우선순위가 달라요 -> 그만큼 많은 시간을 투자하지 못해요 -> 코딩을 공부할 수 있는 계기와 재미를 주자
화려한 웹사이트, 나만의 AI 친구 만들기, >> 코드의 품질을 높이는 것

------------------------------------------

1. store 폴더 생성한다
2. store.js를 작성한다 ---> store.js는 어떤 역할은 하는가, 저장소 생성, 옵션을 설정
    const store = configureStore({
        reducer: {
            todo: todoSlice
        }
    })

3. app.js에서 Provider로 Router를 감싸준다
4. Provider에 store라는 키에 2번에서 생성한 store를 전달한다
5. store에 todo.slice.js를 생성한다
6. todo.slice의 export된 reducer를 store.js에 등록한다/설정한다/할당한다

------------------------------------------

과제 내용

1. updateTodo, deleteTodo --> msw로 생성해서, 백엔드에게 가상 요청하기
2. getTodos만 createThunk 하여 로딩중인 상태 UI 만들기 (너무 빨라서 안보일거에요)
TodoList return if(state.getTodo.loading) return <div>Loading..</div>

------------------------------------------

const todos = [...] // global state

function todo(){
    console.log(todos)
}

function todoList() // props { 
    console.log(todos) // 정의한적 없음 
    todo(todos)
}

function addTodoModal(){
    console.log(todos)
    todos.push(newTodo) // setTodos() --- 화면이 변동될 때

    return <div>{todos.map}</div>
}

function todoPage(){
    todoList() // <TodoList todos={todos} />
    addTodoModal() // <AddTodoModal todos={todos} />
}

------------------------------------------