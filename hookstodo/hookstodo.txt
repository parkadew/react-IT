
1. State Management CRUD

--------------------------------------

ex)
const [todos, setTodos] = useState([
    {
        id : 1,
        title: "example-1",
        content "content-1",
        state: false
    },
    {
        id: 2,
        title: "example-2",
        content "content-2",
        state: true
    }
])

--------------------------------------

todos는 왜 상태여야하는가?

>> todo가 추가되면 one-todo가 사용자 화면에서 하나 증가 (레이아웃 변경)
>> todo가 삭제되면 특정 one-todo가 사용자 화면에서 삭제 (레이아웃 변경)
>> todo가 상태가 변경되어 완료로 변하면 사용자 화면에서 변경 (레이아웃 변경)

--------------------------------------

Create (생성)

생성은 사용자가 입력한 todo가 추가되는 것 ---> one-todo가 화면에서 하나 추가되는 형태

최종으로 구현해야하는 코드

>> ... (전개 연산자를 통한 오브젝트를 복사)

const object = [1,2,3] 주소값이 abcd
const temp_object = object
console.log(temp_object) // [1,2,3]
console.log(object === temp_object) // true --> 복사된게 아니라 같은 배열의 주소를 바라보고 있음

const object = [1,2,3]
const temp_object = [] // 새로운 배열 선언 --> 새로운 주소를 할당 --> 주소값은 efgh
                  = [...object] !== object
                    efgh            abcd

----------------

(1)
const temp_todos = [...todos]
temp_todos.push(newTodo)
setTodos(temp_todos)

(2)
setTodos([...todos, newTodo])

--------------------------------------

이렇게 해야하는 이유?
1. todos는 상태이기 때문에 push할 수 없다 --> setTodos
2. state의 불변성입니다. todos의 주소가 abcd면 todos가 push되었다고 하더라도 변화를 알 수 없음, 주소값이 똑같으니까, efgh의 todos와 똑같은 복사본 배열

상태는 이전 값이랑 똑같으면 setState를 해도 변하지 않습니다.
todos.push(newTodo) // adcd
setTodos(todos) // 기존의 주소값 abcd --- 변경하려는 주소값 abcd
리엑트가 변화했다고 생각하지 않고 상태를 안바꿉니다 --> 주소 값의 변화를 주어야한다 --> <<복사본 배열>> -->> ...


** setTodo([...todos, newTodo])
// newTodo = {
    id: shotId() <-- 랜덤 id 생성
    title: 사용자의 입력값
    content: 사용자의 입력값 ---> form/ref
    state: false ---> default
}

title, content ---> event.target --> title.value, content.value

--------------------------------------

Read (조회)

todos.map((todo) => <OneTodo todo={todo} />)

--------------------------------------

Update (갱신)

** 백엔드가 있을 때
(추가) -- id(x), state(x) --> 백엔드에게 title,content 주고 백엔드에게 다시 데이터 달라고하면 됩니다. ( ...todos, setTodos(X) )

    const fetchTodo = async () => {
        const response = await axios.get("/todo") // 백엔드에 요청
        setTodos(response.data)
    }

    const onPressAddTodo = async(event) => {
        await axios.post("/todo", {title:event.target.title.value, content: event.target.content.value})
        fetchTodo()
    }

(갱신) --> id(백엔드에서 전달한 식별 값)랑 수정된 내용

    const onPressAddTodo = async(event) => {
        await axios.patch("/todo", {id:todoId, ...수정된 내용 })
        fetchTodo()
    }

** 백엔드가 없을 때

    todos 배열을 내가 직접 바꿔야합니다.
    따라서, todos 배열에서 내가 갱신하고 싶은 todo를 찾아내야함
    해당 todo의 속성 값을 바꾸면 됩니다.
    (find, findIndex)

   
    const temp_todos = [...todos] // todos.find(abcd) --> 새로운 복사본
    const selectTodo = temp_todos.find((todo) => todo.id === todoId)
    selectTodo = {
        ...selectTodo, //title, content, state
                        title : selectTodo.title,
                        content : selectTodo.content,
                        state : selectTodo.state,
        title: 수정된 타이틀
        (나중에 나온 속성 값이 덮어씌우기 때문에 순서 중요)
    }

    setTodos(temp_todos)
    input: todoId(고유 식별 값(고유 식별 조건)), 수정된 내용

--------------------------------------

Delete (삭제)

특정 요소 혹은 특정 조건을 만족하는 요소들을 제외한 새로운 배열을 생성해서 상태를 변경
filter -> 특정 조건, 새로운 배열이 생성
                                                       (const todoId = todo.id)
const deleteTodos = todos.filter((todo) => todo.id !== todoId) // todoId인 것이 제외
setTodos(deleteTodos)

--------------------------------------

tost-message를 만들어서 띄워볼겁니다 --> 라이브러리

--------------------------------------